library(purrr)
?map
setwd('/Users/KSauby/Documents/Projects/Dissertation')
library(ProjectTemplate)#
load.project()#
#
# load GTMNERR#
#
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis')#
load.project()#
#
# load ACSampling#
#
setwd('/Users/KSauby/Documents/Projects/ACSampling_project')#
load.project()#
#
# load marsico project#
#
setwd('/Users/KSauby/Documents/Projects/marsico-time-series')#
load.project()
str(Plant.Surveys.by.Year)
str(Plant.Surveys.by.Plant)
Plant.Surveys.by.Plant %>% filter(RangeofDates > 0) %>% head
Plant.Surveys.by.Plant %>% filter(RangeofDates > 0) %>% dim()
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
plants.spanning.multiple.plots <- Plant.Surveys.by.Plant %>% #
	filter(RangeofDates >= 0)
dim(plants.spanning.multiple.plots)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
Plant.Surveys.by.Plant %>% #
	filter(!(is.na(RangeofDates))
)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
plants.spanning.multiple.plots <- Plant.Surveys.by.Plant %>% #
	filter(!(is.na(RangeofDates)))
dim(plants.spanning.multiple.plots)
head(plants.spanning.multiple.plots)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
av.days.to.complete.survey <- mean(plants.spanning.multiple.plots$RangeofDates)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
plants.spanning.multiple.plots <- Plant.Surveys.by.Plant %>% #
	filter(!(is.na(RangeofDates)))
head(plants.spanning.multiple.plots)
str(plants.spanning.multiple.plots)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
plants.spanning.multiple.plots <- Plant.Surveys.by.Plant %>% #
	filter(!(is.na(SizeofDateRange)))
dim(plants.spanning.multiple.plots)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
mean(plants.spanning.multiple.plots$SizeofDateRange)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
min.days.to.complete.survey <- min(plants.spanning.multiple.plots$SizeofDateRange)#
max.days.to.complete.survey <- max(plants.spanning.multiple.plots$SizeofDateRange)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
max.days.to.complete.survey
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
min.days.to.complete.survey
length(unique(plants.spanning.multiple.plots$PlantID))
str(Plant.Info.Analysis)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/munge')
Plant.Info.stricta <- Plant.Info.Analysis %>% filter(Species=="Opuntia stricta")
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/munge')
setwd("/Users/KSauby/Documents/Projects/GTMNERR_analysis")#
cache("Plant.Info.stricta")
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
length(unique(plants.spanning.multiple.plots$PlantID))/length(unique(Plant.Info.stricta$PlantID))
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
length(unique(plants.spanning.multiple.plots$PlantID))/length(unique(Plant.Info.stricta$PlantID)) %>% round(2)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
length(unique(plants.spanning.multiple.plots$PlantID))/length(unique(Plant.Info.stricta$PlantID)) %$% round(2)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
round(#
	length(unique(plants.spanning.multiple.plots$PlantID)) / #
		length(unique(Plant.Info.stricta$PlantID)),#
	2#
)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
round(#
	length(unique(plants.spanning.multiple.plots$PlantID)) / #
		length(unique(Plant.Info.stricta$PlantID)),#
	2#
) * 100
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
round(#
	mean(plants.spanning.multiple.plots$SizeofDateRange),#
	2#
)
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography')
plants.spanning.multiple.plots <- Plant.Surveys.by.Plant %>% #
	filter(!(is.na(SizeofDateRange)))#
av.days.to.complete.survey <- round(#
	mean(plants.spanning.multiple.plots$SizeofDateRange),#
	2#
) #
#
min.days.to.complete.survey <- min(plants.spanning.multiple.plots$SizeofDateRange)#
max.days.to.complete.survey <- max(plants.spanning.multiple.plots$SizeofDateRange)#
n.plants.spanning.multiple.plots <- length(unique(plants.spanning.multiple.plots$PlantID))#
perc.plants.spanning.multiple.plots <- round(#
	length(unique(plants.spanning.multiple.plots$PlantID)) / #
		length(unique(Plant.Info.stricta$PlantID)),#
	2#
) * 100
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects')
setwd("./GTMNERRproc")#
#setwd("./dataproc")#
#setwd("./modresproc")#
#setwd("./unmarked")#
#setwd("./RPresence")#
#devtools::test()#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography/Appendix')
parent.methods <- c(#
	"largest",#
	"random",#
	"random (probability of selection weighted by size)"#
)#
data.list.2013 <- c(#
	"mod.4.stages.2013.mat.data",#
	"mod.5.stages.2013.mat.data",#
	"mod.5.stages.b.2013.mat.data",#
	"mod.6.stages.2013.mat.data",#
	"mod.7.stages.2013.mat.data"#
)#
printPopulationMatrices(#
	data.list=data.list.2013, #
	parent.method, #
	years="2013-2014", #
	first.year="2013"#
)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("###", dat$N.Stages.wo.break, "\n")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage ")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("####", dat$N.Stages.wo.break, "\n")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography/Appendix')
parent.methods <- c(#
	"largest",#
	"random",#
	"random (probability of selection weighted by size)"#
)#
data.list.2013 <- c(#
	"mod.4.stages.2013.mat.data",#
	"mod.5.stages.2013.mat.data",#
	"mod.5.stages.b.2013.mat.data",#
	"mod.6.stages.2013.mat.data",#
	"mod.7.stages.2013.mat.data"#
)#
printPopulationMatrices(#
	data.list=data.list.2013, #
	parent.method, #
	years="2013-2014", #
	first.year="2013"#
)
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("###", dat$N.Stages.wo.break, "\n")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage \n")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("####", dat$N.Stages.wo.break, "\n")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects')
setwd("./GTMNERRproc")#
#setwd("./dataproc")#
#setwd("./modresproc")#
#setwd("./unmarked")#
#setwd("./RPresence")#
#devtools::test()#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage \n")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("####", dat$N.Stages.wo.break, "\n")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography/Appendix')
parent.methods <- c(#
	"largest",#
	"random",#
	"random (probability of selection weighted by size)"#
)#
data.list.2013 <- c(#
	"mod.4.stages.2013.mat.data",#
	"mod.5.stages.2013.mat.data",#
	"mod.5.stages.b.2013.mat.data",#
	"mod.6.stages.2013.mat.data",#
	"mod.7.stages.2013.mat.data"#
)#
printPopulationMatrices(#
	data.list=data.list.2013, #
	parent.method, #
	years="2013-2014", #
	first.year="2013"#
)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")
?cat
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage \n")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("####", dat$N.Stages.wo.break, "\n")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography/Appendix')
parent.methods <- c(#
	"largest",#
	"random",#
	"random (probability of selection weighted by size)"#
)#
data.list.2013 <- c(#
	"mod.4.stages.2013.mat.data",#
	"mod.5.stages.2013.mat.data",#
	"mod.5.stages.b.2013.mat.data",#
	"mod.6.stages.2013.mat.data",#
	"mod.7.stages.2013.mat.data"#
)#
printPopulationMatrices(#
	data.list=data.list.2013, #
	parent.method, #
	years="2013-2014", #
	first.year="2013"#
)
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects')
setwd("./GTMNERRproc")#
#setwd("./dataproc")#
#setwd("./modresproc")#
#setwd("./unmarked")#
#setwd("./RPresence")#
#devtools::test()#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{", parent.methods[j], "parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsubsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects')
setwd("./GTMNERRproc")#
#setwd("./dataproc")#
#setwd("./modresproc")#
#setwd("./unmarked")#
#setwd("./RPresence")#
#devtools::test()#
devtools::document()#
devtools::install()
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsubsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsubsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsubsection{", LTRE_variable, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsubsection{", LTRE_variable, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method for the",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						".",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						") using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Successively print population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#'#
#' @export#
#
printPopulationMatrices <- function(data.list, parent.method, years, first.year) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsection{", dat$N.Stages.wo.break, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat("\\subsubsection{ ``", parent.methods[j], "'' parent assignment method}", sep="")#
			cat('\n')  #
			print(#
				xtable(#
					dat[[1]][[j]]$clone_transition_counts, #
					digits=0,#
					caption=paste(#
						"Clone production counts (",#
						years,#
						" data) using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts (",#
						years,#
						" data) using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[1]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" using the \`\`",#
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}#
#' Successively print LTRE population matrices for inclusion in an appendix#
#'#
#' @param data.list#
#' @param parent.method#
#' @param  years#
#' @param first.year#
#' @param LTRE_variable#
#'#
#' @export#
printLTREPopulationMatrices <- function(data.list, parent.method, years, first.year, LTRE_variable) {#
	for (i in 1:length(data.list)) {#
		dat <- eval(parse(text=data.list[i]))#
		cat("\\subsubsection{", LTRE_variable, "}", sep="")#
		for (j in 1:length(parent.methods)){#
			cat('\n')  #
			print(#
				xtable(#
					dat[[4]][[j]]$clone_transition_counts, #
					digits=0, #
					caption=paste(#
						"Clone production counts using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method for the ",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						".",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$transition.counts, #
					digits=0,#
					caption=paste(#
						"Growth, stasis, retrogression, and survival counts using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method for the ",#
						years,#
						" data for plants ",#
						LTRE_variable,#
						".",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			print(#
				xtable(#
					dat[[4]][[j]]$n_per_stage %>% filter(stage!="Seed"), #
					digits=0,#
					caption=paste(#
						"Number of individuals per stage in ",#
						first.year,#
						" for plants ",#
						LTRE_variable,#
						", using the \`\`", #
						parent.methods[j],#
						"\'\' parent assignment method.",#
						sep=""#
					)#
				),#
				include.rownames=F, caption.placement = "top"#
			)#
			cat("\\clearpage")#
		}#
	}#
}
setwd('/Users/KSauby/Documents/Projects/Dissertation')
bookdown::render_book('index.Rmd')
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography/population_modeling_files')
source("processing/values_same_across_all_models.R")#
source("processing/prep_ldf_cldf.R")#
# ---------------------------------------------------------------------------- ##
TransitionYear 	= 2013#
source("processing/mutate_ldf_cldf.R")
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
SizeClass <- SizeClass#
	A <- list()#
	for (i in 1:length(ldf)) {#
		A[[i]] <- prepDataTransitionMatrix(#
			ldf[[i]], #
			cldf[[i]], #
			SizeClass, #
			TransitionYear#
		)#
	}
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography/population_modeling_files/2013_2014')
SizeClass <- SizeClass.4
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
SizeClass <- SizeClass#
	A <- list()#
	for (i in 1:length(ldf)) {#
		A[[i]] <- prepDataTransitionMatrix(#
			ldf[[i]], #
			cldf[[i]], #
			SizeClass, #
			TransitionYear#
		)#
	}
A
Dat <- ldf[[i]]
clonal_repro_dataset <- cldf[[i]]
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Dat_census <- Dat %>% #
	rowwise() %>%#
	mutate(#
		stage=replace(#
			stage, #
			which(stage=="Adult"),#
			cut(SizewClones_t, SizeClass, include.lowest=T, labels=FALSE)#
		)#
	)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Dat_census %<>%#
		dplyr::select(#
			FecundityYear, #
			PlantID, #
			stage, #
			Fruit_Flowers_t#
		)#
	colnames(Dat_census)[which(names(Dat_census) == "FecundityYear")] <- "Year"#
	# merge year with year - 1#
	trans <- subset(#
		merge(#
			Dat_census, #
			Dat_census, #
			by = "PlantID", #
			sort = FALSE#
		), #
		Year.x == Year.y - 1#
	)#
	# rename rows and columns#
	rownames(trans) <- 1:nrow(trans)#
	colnames(trans)[which(names(trans) == "Year.x")] 			<- "Year"#
	colnames(trans)[which(names(trans) == "stage.x")] 			<- "stage"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.x")] <- "Repro"#
	colnames(trans)[which(names(trans) == "Year.y")] 			<- "Year2"#
	colnames(trans)[which(names(trans) == "stage.y")] 			<- "fate"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.y")] <- "Repro2"
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
trans01 <- trans %>%#
		filter(Year == TransitionYear) %>%#
		dplyr::select(PlantID, stage, Repro, fate, Repro2)#
	seedlings <- nrow(subset(#
		Dat_census, #
		Year == TransitionYear & stage =="Seedling"#
	))
head(trans01)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
trans01 %<>% mutate(Seedling = Repro/sum(Repro, na.rm=T) * seedlings)
head(trans01)
tail(trans01)
trans01 %>% filter(Seedling > 0) %>% head
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
seedlings
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Seedlings <- nrow(subset(trans, Year == TransitionYear & stage=="Seedling"))
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Seedlings
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
c(unique(c(trans01$stage, trans01$fate))) %>% #
		as.numeric %>%#
		na.omit %>% #
		as.vector %>%#
		sort
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
stages <- c(unique(c(trans01$stage, trans01$fate))) %>% #
		as.numeric %>%#
		na.omit %>% #
		as.vector %>%#
		sort#
	stages <- c("Seed", "Seedling", stages, "dead")#
	trans01$stage %<>% factor(., levels=stages[-length(stages)], ordered=T)#
	trans01$fate %<>% factor(., levels=stages, ordered=T)
head(trans01)
tail(trans01)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
stages %<>% .[-length(.)]#
	proj_matrix <- projection.matrix(#
		trans01, #
		sort = stages#
	)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
proj_matrix
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Dat_census <- Dat %>% #
	rowwise() %>%#
	mutate(#
		stage=replace(#
			stage, #
			which(stage=="Adult"),#
			cut(SizewClones_t, SizeClass, include.lowest=T, labels=FALSE)#
		)#
	)#
	Dat_census %<>%#
		dplyr::select(#
			FecundityYear, #
			PlantID, #
			stage, #
			Fruit_Flowers_t#
		)#
	colnames(Dat_census)[which(names(Dat_census) == "FecundityYear")] <- "Year"#
	# merge year with year - 1#
	trans <- subset(#
		merge(#
			Dat_census, #
			Dat_census, #
			by = "PlantID", #
			sort = FALSE#
		), #
		Year.x == Year.y - 1#
	)#
	# rename rows and columns#
	rownames(trans) <- 1:nrow(trans)#
	colnames(trans)[which(names(trans) == "Year.x")] 			<- "Year"#
	colnames(trans)[which(names(trans) == "stage.x")] 			<- "stage"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.x")] <- "Repro"#
	colnames(trans)[which(names(trans) == "Year.y")] 			<- "Year2"#
	colnames(trans)[which(names(trans) == "stage.y")] 			<- "fate"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.y")] <- "Repro2"#
#
	# year-specific transition matrix#
	trans01 <- trans %>%#
		filter(Year == TransitionYear) %>%#
		dplyr::select(PlantID, stage, Repro, fate, Repro2)#
	seedlings <- nrow(subset(#
		Dat_census, #
		Year == TransitionYear & stage =="Seedling"#
	))#
	# number of seedlings estimated to have been produced by each stage class#
	trans01 %<>% mutate(Seedling = Repro/sum(Repro, na.rm=T) * seedlings)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
stages <- c(unique(c(trans01$stage, trans01$fate))) %>% #
		as.numeric %>%#
		na.omit %>% #
		as.vector %>%#
		sort#
	stages <- c("Seed", "Seedling", stages, "dead")#
	trans01$stage %<>% factor(., levels=stages[-length(stages)], ordered=T)#
	trans01$fate %<>% factor(., levels=stages, ordered=T)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
stages %<>% .[-length(.)]
stages
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
matrix
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
projection.matrix
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
projection.matrix(#
		trans01, #
		sort = stages#
	)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
stages
length(trans01)
dim(trans01)
0.197131576 * 963
0.197131576 * 963 + 0.001653127*963 + 0.002399123*963
sum(trans01$Repro)
sum(trans01$Repro,na.r=T)
sum(trans01$Repro,na.rm=T)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
SizeClass <- SizeClass#
	A <- list()#
	for (i in 1:length(ldf)) {#
		A[[i]] <- prepDataTransitionMatrix(#
			ldf[[i]], #
			cldf[[i]], #
			SizeClass, #
			TransitionYear#
		)#
	}
A
i=1
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
trans_data = A[[i]]
i=1
j=1
k=1
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
createProjectionMatrix(#
					trans_data$trans01,#
					SeedBankSize[i],#
					SeedsPerFruit[j],#
					SeedSurvival[k]#
				)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Seedlings 			<- trans_data %>% filter(stage =="Seedling") %>% nrow
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
projection.matrix(#
		trans01, #
		sort = stages#
	)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
#' Prepare Data For Transition Matrix Function#
#'#
#' @param Dat Dataset#
#' @param SizeClass Classes into which to divide individuals based on size#
#' @param TransitionYear Year#
#
#' @description Prepare Data For Transition Matrix Function#
#'#
#' @export#
#
prepDataTransitionMatrix <- function(#
	Dat,#
	clonal_repro_dataset,#
	SizeClass,#
	TransitionYear#
) {#
	# Dat$stage <- Dat$Stage#
	Dat_census <- Dat %>% #
	rowwise() %>%#
	mutate(#
		stage=replace(#
			stage, #
			which(stage=="Adult"),#
			cut(SizewClones_t, SizeClass, include.lowest=T, labels=FALSE)#
		)#
	)#
	Dat_census %<>%#
		dplyr::select(#
			FecundityYear, #
			PlantID, #
			stage, #
			Fruit_Flowers_t#
		)#
	colnames(Dat_census)[which(names(Dat_census) == "FecundityYear")] <- "Year"#
	# merge year with year - 1#
	trans <- subset(#
		merge(#
			Dat_census, #
			Dat_census, #
			by = "PlantID", #
			sort = FALSE#
		), #
		Year.x == Year.y - 1#
	)#
	# rename rows and columns#
	rownames(trans) <- 1:nrow(trans)#
	colnames(trans)[which(names(trans) == "Year.x")] 			<- "Year"#
	colnames(trans)[which(names(trans) == "stage.x")] 			<- "stage"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.x")] <- "Repro"#
	colnames(trans)[which(names(trans) == "Year.y")] 			<- "Year2"#
	colnames(trans)[which(names(trans) == "stage.y")] 			<- "fate"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.y")] <- "Repro2"#
#
	# year-specific transition matrix#
	trans01 <- trans %>%#
		filter(Year == TransitionYear) %>%#
		dplyr::select(PlantID, stage, Repro, fate, Repro2)#
	# seedlings <- nrow(subset(#
	#	Dat_census, #
	#	Year == TransitionYear & stage =="Seedling"#
	#))#
	# number of seedlings estimated to have been produced by each individual#
	# trans01 %<>% mutate(Seedling = Repro/sum(Repro, na.rm=T) * seedlings)#
	# create full set of stages#
	stages <- c(unique(c(trans01$stage, trans01$fate))) %>% #
		as.numeric %>%#
		na.omit %>% #
		as.vector %>%#
		sort#
	stages <- c("Seed", "Seedling", stages, "dead")#
	trans01$stage %<>% factor(., levels=stages[-length(stages)], ordered=T)#
	trans01$fate %<>% factor(., levels=stages, ordered=T)#
	# remove last stage#
	stages %<>% .[-length(.)]#
	proj_matrix <- projection.matrix(#
		trans01, #
		sort = stages#
	)#
	# create matrix of transition counts#
	transition.counts <- table(trans01$fate, trans01$stage)#
	# create clonal matrices#
	clonal.matrices <- createClonalReproTransitionMatrix(#
		clonal_repro_dataset, #
		trans01,#
		stages#
	)#
	return(list(#
		clone_transition_counts = clonal.matrices[[1]],#
		clone_transition_rates = clonal.matrices[[2]], #
		transition.counts = transition.counts, #
		proj_matrix = proj_matrix, #
		trans01 = trans01, #
		stages = stages,#
		n_per_stage = clonal.matrices[[3]]#
	))#
}
setwd('/Users/KSauby/Documents/Projects/GTMNERR_analysis/Manuscript/Demography/population_modeling_files/2013_2014')
SizeClass <- SizeClass.4
i
Dat <- ldf[[i]]
clonal_repro_dataset <- cldf[[i]]
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Dat_census <- Dat %>% #
	rowwise() %>%#
	mutate(#
		stage=replace(#
			stage, #
			which(stage=="Adult"),#
			cut(SizewClones_t, SizeClass, include.lowest=T, labels=FALSE)#
		)#
	)#
	Dat_census %<>%#
		dplyr::select(#
			FecundityYear, #
			PlantID, #
			stage, #
			Fruit_Flowers_t#
		)#
	colnames(Dat_census)[which(names(Dat_census) == "FecundityYear")] <- "Year"#
	# merge year with year - 1#
	trans <- subset(#
		merge(#
			Dat_census, #
			Dat_census, #
			by = "PlantID", #
			sort = FALSE#
		), #
		Year.x == Year.y - 1#
	)#
	# rename rows and columns#
	rownames(trans) <- 1:nrow(trans)#
	colnames(trans)[which(names(trans) == "Year.x")] 			<- "Year"#
	colnames(trans)[which(names(trans) == "stage.x")] 			<- "stage"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.x")] <- "Repro"#
	colnames(trans)[which(names(trans) == "Year.y")] 			<- "Year2"#
	colnames(trans)[which(names(trans) == "stage.y")] 			<- "fate"#
	colnames(trans)[which(names(trans) == "Fruit_Flowers_t.y")] <- "Repro2"#
#
	# year-specific transition matrix#
	trans01 <- trans %>%#
		filter(Year == TransitionYear) %>%#
		dplyr::select(PlantID, stage, Repro, fate, Repro2)#
	# seedlings <- nrow(subset(#
	#	Dat_census, #
	#	Year == TransitionYear & stage =="Seedling"#
	#))#
	# number of seedlings estimated to have been produced by each individual#
	# trans01 %<>% mutate(Seedling = Repro/sum(Repro, na.rm=T) * seedlings)#
	# create full set of stages#
	stages <- c(unique(c(trans01$stage, trans01$fate))) %>% #
		as.numeric %>%#
		na.omit %>% #
		as.vector %>%#
		sort#
	stages <- c("Seed", "Seedling", stages, "dead")#
	trans01$stage %<>% factor(., levels=stages[-length(stages)], ordered=T)#
	trans01$fate %<>% factor(., levels=stages, ordered=T)#
	# remove last stage#
	stages %<>% .[-length(.)]#
	proj_matrix <- projection.matrix(#
		trans01, #
		sort = stages#
	)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
projection.matrix(#
		trans01, #
		sort = stages#
	)
trans_data <- trans01
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
SeedBankSize
reateProjectionMatrix(#
					trans01,#
					SeedBankSize[i],#
					SeedsPerFruit[j],#
					SeedSurvival[k]#
				)
createProjectionMatrix(#
					trans01,#
					SeedBankSize[i],#
					SeedsPerFruit[j],#
					SeedSurvival[k]#
				)
projection.matrix(#
		trans01, #
		sort = stages#
	)
createProjectionMatrix(#
					trans01,#
					SeedBankSize[i],#
					SeedsPerFruit[j],#
					SeedSurvival[k]#
				)
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Seedlings 			<- trans_data %>% filter(stage =="Seedling") %>% nrow#
	seeds.from.plants 	<- sum(trans_data$Repro, na.rm=T) * SeedsPerFruit
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
Seedlings
setwd('/Users/KSauby/Documents/Projects/GTMNERRproc/R')
seeds.from.plants
dim(trans01)
trans01 %>% filter(Repro > 0) dim
trans01 %>% filter(Repro > 0) %>% dim
trans01 %>% filter(Repro > 0) %$% sum(Repro)
trans01 %$% sum(Repro,na.rm=T)
trans01 %>% filter(Repro > 0)
setwd('/Users/KSauby/Documents/Projects')
setwd("./GTMNERRproc")#
#setwd("./dataproc")#
#setwd("./modresproc")#
#setwd("./unmarked")#
#setwd("./RPresence")#
#devtools::test()#
devtools::document()#
devtools::install()
